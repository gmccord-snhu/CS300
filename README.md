# CS300
Repository for CS300

## What was the problem you were solving in the projects for this course?
The problem addressed in this course was understanding how to effectively store and manage data using various data structures, specifically hash tables, binary search trees, and vectors. This involved not only implementing these structures but also developing algorithms for key operations such as insertion, removal, and updates. The goal was to analyze the efficiency of each structure in terms of time complexity and memory usage while applying these concepts to real-world scenarios, such as a course management system.

## How did you approach the problem?
I began by examining the requirements of the project and understanding the benefits and drawbacks of each data storage approach. This involved researching how each structure operates under different scenarios, such as the average and worst-case performance of hash tables compared to binary trees and vectors. I created a comparison chart to visualize these aspects, which helped me decide which structures to implement for the course management system.

## How did you overcome any roadblocks you encountered while going through the activities or project?
One significant roadblock I faced was implementing the hash table, particularly due to challenges with collision resolution. This concept was new to me, and I initially struggled to understand how to effectively manage collisions to ensure efficient data retrieval. To overcome this, I engaged in experimentation and testing different collision resolution strategies and often returned to the course Zybooks material. This experience deepened my understanding of hash tables and various approaches for implementing them.

## How has your work on this project expanded your approach to designing software and developing programs?
Working on this project has significantly broadened my understanding of how to select appropriate data structures based on specific needs and constraints. It emphasized the importance of analyzing performance metrics, making me more deliberate in my design choices. I now approach software design with a critical eye, carefully considering the trade-offs involved in different structures and algorithms. Additionally, my hands-on experience with these data structures has increased my comfort level with them, as I feel much more confident applying what I’ve learned rather than just reading about them.

## How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
The project highlighted the significance of writing clean, modular code. By focusing on proper documentation, clear naming conventions, and breaking down functions into smaller, reusable components, I’ve greatly improved the maintainability and readability of my programs. Even though the code is within a classroom setting, I made a conscious effort to apply these principles rigorously. 
